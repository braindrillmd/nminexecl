# Тестовое задание

## Инструкция по запуску

### Клонирование репозитория
Склонировать репозиторий по ссылке:<br />https://github.com/braindrillmd/nminexecl.git<br />
* InteliJ IDEA: New -> Project from Version Control
* Чере git:<br />
<code>git clone https://github.com/braindrillmd/nminexecl.git</code>

### Запуск через IDE
Открыть class *NminexcelApplication* и запустить в IDEA или другой IDE. API будет доступен на
локальной машине по ссылке:<br />http://localhost:8080/swagger-ui/index.html<br/>

### Варианты запуска в докере
* Запустить docker-compose через IDEA
* Перейти в папку проекта и выполнить команду<br />
<code>docker-compose up</code><br />

Проект соберется, развернется и запустится автоматически. API будет доступен по той же ссылке:
<br />http://localhost:8080/swagger-ui/index.html<br />Тестовые файлы добавлены в образ для
удобства. Если нужно оперативнее и быстрее подкидывать файлы, можно раскомментировать в 
docker-compose.yaml эти строчки:<br />
<code>volumes:<br />
     - "D:/temp/data:/app/data/mnt"</code><br />
и примонтировать папку с локальный машины, указав необходимый путь

## Комментарии к проекту

### Почему так
Max-heap позволяет хранить только актуальные элементы (сама куча хоть и max, хранит она N 
минимальных элементов на i-ой итерации). Помимо этого мы сразу отсеиваем повторные элементы, для 
поиска которых дерево подходит лучше всего. Поскольку элементы мы получаем в любом случае по одному, 
куча - оптимальный подход.<br /><br />
Сам файл читается в потоке, что позволяет не загружать его в память полностью, а значит обрабатывать
файлы любого размера. Опять же, поэлементное считывание и куча - идеальное сочетание.
Обеспечивается временная сложность O(n*log n) и линейная пространственная сложность. 

### Как можно еще
* записать числа в массив и отсортировать quicksort, а еще лучше использовать quickselect. Временная
сложность также O(n*log n). Однако, если файл большой, то и временный массив будет велик
* если известно, что диапазон чисел невелик, можно использовать сортировку массива подсчетом,
предварительно определив *n-max* и *n-min* на этапе обработки файла. Потребуется дополнительный
массив, но если диапазон невелик, массив будет относительно небольшим, а алгоритм будет работать
линейное время, но это крайней специфичный случай

### Что можно поменять
Можно передавать файл через multipart прямо в API, но тогда появляются ограничения на размер файла 